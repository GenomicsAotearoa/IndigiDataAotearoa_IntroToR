{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Introduction to R at IndigiData Aotearoa Goals \u00b6 What is R and why is it relevant for bioinformatics? Introduction to coding in R: functions and objects Use R to investigate genetic diversity between populations. Use ggplot2 to create high quality images.","title":"Home"},{"location":"#goals","text":"What is R and why is it relevant for bioinformatics? Introduction to coding in R: functions and objects Use R to investigate genetic diversity between populations. Use ggplot2 to create high quality images.","title":"Goals"},{"location":"1_Background/","text":"Introduction to the R programming languange \u00b6 Info Keypoints Objectives R is a powerful, popular open-source scripting language RStudio allows you to run R in an easy-to-use interface and makes it easy to find help A popular language for it's use in statistical analysis and visualisation tools Create an RStudio project, and know the benefits of working within a project Be able to locate and change the current working directory with getwd() and setwd() Compose an R script file containing comments and commands Understand what an R function is Locate help for an R function using ? , ?? , and args() Use R to visualise population-specific frequencies of medically relevant genetic variants A brief history of R \u00b6 R has been around since 1995, and was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R is based off the S programming language developed at Bell Labs and was developed to teach intro statistics. Advantages of using R \u00b6 At more than 20 years old, R is fairly mature and growing in popularity . However, programming isn't a popularity contest. Here are key advantages of analyzing data in R: R is open source . This means R is free - an advantage if you are at an institution where you have to pay for your own MATLAB or SAS license. Open source is important to your colleagues in parts of the world where expensive software in inaccessible. It also means that R is actively developed by a community (see r-project.org ), and there are regular updates. R is widely used . Ok, maybe programming is a popularity contest. Because R is used in many areas (not just bioinformatics), you are more likely to find help online when you need it. Chances are, almost any error message you run into, someone else has already experienced. R is powerful . R runs on multiple platforms (Windows/MacOS/Linux). It can work with much larger datasets than popular spreadsheet programs like Microsoft Excel, and because of its scripting capabilities is far more reproducible. Also, there are thousands of available software packages for science, including genomics and other areas of life science. Introducing RStudio Server \u00b6 In these lessons, we will be making use of a software called RStudio , an Integrated Development Environment (IDE) . RStudio, like most IDEs, provides a graphical interface to R, making it more user-friendly, and providing dozens of useful features. We will introduce additional benefits of using RStudio as you cover the lessons. Source : This pane is where you will write/view R scripts. Some outputs (such as if you view a dataset using View() ) will appear as a tab here. Console/Terminal/Jobs : This is actually where you see the execution of commands. This is the same display you would see if you were using R at the command line without RStudio. You can work interactively (i.e. enter R commands here), but for the most part we will run a script (or lines in a script) in the source pane and watch their execution and output here. The \"Terminal\" tab give you access to the BASH terminal (the Linux operating system, unrelated to R). RStudio also allows you to run jobs (analyses) in the background. This is useful if some analysis will take a while to run. You can see the status of those jobs in the background. Environment/History : Here, RStudio will show you what datasets and objects (variables) you have created and which are defined in memory. You can also see some properties of objects/datasets such as their type and dimensions. The \"History\" tab contains a history of the R commands you've executed R. Files/Plots/Packages/Help/Viewer : This multipurpose pane will show you the contents of directories on your computer. You can also use the \"Files\" tab to navigate and set the working directory. The \"Plots\" tab will show the output of any plots generated. In \"Packages\" you will see what packages are actively loaded, or you can attach installed packages. \"Help\" will display help files for R functions and packages. \"Viewer\" will allow you to view local web content (e.g. HTML outputs). Create an RStudio project \u00b6 One of the first benefits we will take advantage of in RStudio is something called an RStudio Project . An RStudio project allows you to more easily: Save data, files, variables, packages, etc. related to a specific analysis project Restart work where you left off Collaborate, especially if you are using version control such as git . To create a project, go to the File menu, and click New Project In the window that opens select Existing Directory Then select Browse.... Choose and then click \"~/Documents/IndigiDataIntroToR\". Finally click Create Project . In the \"Files\" tab of your output pane (more about the RStudio layout in a moment), you should see an RStudio project file, IndigiDataIntroToR.Rproj . All RStudio projects end with the \" .Rproj \" file extension. Creating your first R script \u00b6 Now that we are ready to start exploring R, we will want to keep a record of the commands we are using. To do this we can create an R script: Click the File menu and select New File and then R Script . Before we go any further, save your script by clicking the save/disk icon that is in the bar above the first line in the script editor, or click the File menu and select save . In the \"Save File\" window that opens, name your file \"indigidataIntroToR\" . The new script indigidataIntroToR.R should appear under \"files\" in the output pane. By convention, R scripts end with the file extension .R . Getting to work with R: navigating directories \u00b6 Now that we have covered the more aesthetic aspects of RStudio, we can get to work using some commands. We will write, execute, and save the commands we learn in our indigidataIntroToR.R script that is loaded in the Source pane. First, lets see what directory we are in. To do so, type the following command into the script: R-project getwd() To execute this command, make sure your cursor is on the same line the command is written. Then click the Run button that is just above the first line of your script in the header of the Source pane. In the console, we expect to see the following output : [1] \"/home/Documents/IndigiDataIntroToR\" Notice, at the Console, you will also see the instruction you executed above the output in blue. Since we will be learning several commands, we may already want to keep some short notes in our script to explain the purpose of the command. Entering a # before any line in an R script turns that line into a comment, which R will not try to interpret as code. Edit your script to include a comment on the purpose of commands you are learning, e.g.: R-project `# this command shows the current working directory getwd()` Exercise : Work interactively in R What happens when you try to enter the getwd() command in the Console pane? Solution You will get the same output you did as when you ran getwd() from the source. You can run any command in the Console, however, executing it from the source script will make it easier for us to record what we have done, and ultimately run an entire script, instead of entering commands one-by-one. For the purposes of this exercise we want you to be in the directory \"/home/<USERID>/IndigiDataIntroToR\" . What if you weren't? You can set your home directory using the setwd() command. Alternatively, RStudio has a helpful button for setting your working directory ( note that this is a very simplified way to set your working directory, and this is actually a bit more complex in practice.) Using functions in R, without needing to master them \u00b6 A function in R (or any computing language) is a short program that takes some input and returns some output. Functions may seem like an advanced topic (and they are), but you have already used at least one function in R. getwd() is a function! The next sections will help you understand what is happening in any R script. Exercise: What do these functions do? Try the following functions by writing them in your script. See if you can guess what they do, and make sure to add comments to your script about your assumed purpose. - dir() - sessionInfo() - date() - Sys.time() Solution dir() # Lists files in the working directory sessionInfo() # Gives the version of R and additional info including on attached packages date() # Gives the current date Sys.time() # Gives the current time .libPaths() # Shows what libraries are available Notice : Commands are case sensitive! You have hopefully noticed a pattern - an R function has three key properties: Functions have a name (e.g. dir , getwd ); note that functions are case sensitive! Following the name, functions have a pair of () Inside the parentheses, a function may take 0 or more arguments. An argument may be a specific input for your function and/or may modify the function's behavior. For example the function round() will round a number with a decimal: R-project # This will round a number to the nearest integer round(3.14) Getting help with function arguments \u00b6 What if you wanted to round to one significant digit? round() can do this, but you may first need to read the help to find out how. To see the help (In R sometimes also called a \"vignette\") enter a ? in front of the function name: R-project ?round() The \"Help\" tab will show you information (often, too much information). You will slowly learn how to read and make sense of help files. Checking the \"Usage\" or \"Examples\" headings is often a good place to look first. If you look under \"Arguments,\" we also see what arguments we can pass to this function to modify its behavior. You can also see a function's argument using the args() function: R-project args(round) round() takes two arguments, x , which is the number to be rounded, and a digits argument. The = sign indicates that a default (in this case 0) is already set. Since x is not set, round() requires we provide it, in contrast to digits where R will use the default value 0 unless you explicitly provide a different value. We can explicitly set the digits parameter when we call the function: R-project round(3.14159, digits = 2) Or, R accepts what we call \"positional arguments\", if you pass a function arguments separated by commas, R assumes that they are in the order you saw when we used args() . In the case below that means that x is 3.14159 and digits is 2. R-project round(3.14159, 2) Finally, what if you are using ? to get help for a function in a package not installed on your system, such as when you are running a script which has dependencies. R-project geom_point() will return an error: Error Error in .helpForCall(topicExpr, parent.frame()) : no methods for \u2018geom_point\u2019 and no documentation for it as a function Use two question marks (i.e. ??geom_point() ) and R will return results from a search of the documentation for packages you have installed on your computer in the \"Help\" tab. Finally, if you think there should be a function, for example a statistical test, but you aren't sure what it is called in R, or what functions may be available, use the help.search() function. Exercise: Searching for R functions Use help.search() to find R functions for the following statistical functions. Remember to put your search query in quotes inside the function's parentheses. Chi-Squared test Student t-test mixed linear model Success While your search results may return several tests, we list a few you might find: Chi-Squared test: stats::Chisquare Student t-test: stats::t.test mixed linear model: stats::lm.glm","title":"Introduction to the R programming languange"},{"location":"1_Background/#introduction-to-the-r-programming-languange","text":"Info Keypoints Objectives R is a powerful, popular open-source scripting language RStudio allows you to run R in an easy-to-use interface and makes it easy to find help A popular language for it's use in statistical analysis and visualisation tools Create an RStudio project, and know the benefits of working within a project Be able to locate and change the current working directory with getwd() and setwd() Compose an R script file containing comments and commands Understand what an R function is Locate help for an R function using ? , ?? , and args() Use R to visualise population-specific frequencies of medically relevant genetic variants","title":"Introduction to the R programming languange"},{"location":"1_Background/#a-brief-history-of-r","text":"R has been around since 1995, and was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R is based off the S programming language developed at Bell Labs and was developed to teach intro statistics.","title":"A brief history of R"},{"location":"1_Background/#advantages-of-using-r","text":"At more than 20 years old, R is fairly mature and growing in popularity . However, programming isn't a popularity contest. Here are key advantages of analyzing data in R: R is open source . This means R is free - an advantage if you are at an institution where you have to pay for your own MATLAB or SAS license. Open source is important to your colleagues in parts of the world where expensive software in inaccessible. It also means that R is actively developed by a community (see r-project.org ), and there are regular updates. R is widely used . Ok, maybe programming is a popularity contest. Because R is used in many areas (not just bioinformatics), you are more likely to find help online when you need it. Chances are, almost any error message you run into, someone else has already experienced. R is powerful . R runs on multiple platforms (Windows/MacOS/Linux). It can work with much larger datasets than popular spreadsheet programs like Microsoft Excel, and because of its scripting capabilities is far more reproducible. Also, there are thousands of available software packages for science, including genomics and other areas of life science.","title":"Advantages of using R"},{"location":"1_Background/#introducing-rstudio-server","text":"In these lessons, we will be making use of a software called RStudio , an Integrated Development Environment (IDE) . RStudio, like most IDEs, provides a graphical interface to R, making it more user-friendly, and providing dozens of useful features. We will introduce additional benefits of using RStudio as you cover the lessons. Source : This pane is where you will write/view R scripts. Some outputs (such as if you view a dataset using View() ) will appear as a tab here. Console/Terminal/Jobs : This is actually where you see the execution of commands. This is the same display you would see if you were using R at the command line without RStudio. You can work interactively (i.e. enter R commands here), but for the most part we will run a script (or lines in a script) in the source pane and watch their execution and output here. The \"Terminal\" tab give you access to the BASH terminal (the Linux operating system, unrelated to R). RStudio also allows you to run jobs (analyses) in the background. This is useful if some analysis will take a while to run. You can see the status of those jobs in the background. Environment/History : Here, RStudio will show you what datasets and objects (variables) you have created and which are defined in memory. You can also see some properties of objects/datasets such as their type and dimensions. The \"History\" tab contains a history of the R commands you've executed R. Files/Plots/Packages/Help/Viewer : This multipurpose pane will show you the contents of directories on your computer. You can also use the \"Files\" tab to navigate and set the working directory. The \"Plots\" tab will show the output of any plots generated. In \"Packages\" you will see what packages are actively loaded, or you can attach installed packages. \"Help\" will display help files for R functions and packages. \"Viewer\" will allow you to view local web content (e.g. HTML outputs).","title":"Introducing RStudio Server"},{"location":"1_Background/#create-an-rstudio-project","text":"One of the first benefits we will take advantage of in RStudio is something called an RStudio Project . An RStudio project allows you to more easily: Save data, files, variables, packages, etc. related to a specific analysis project Restart work where you left off Collaborate, especially if you are using version control such as git . To create a project, go to the File menu, and click New Project In the window that opens select Existing Directory Then select Browse.... Choose and then click \"~/Documents/IndigiDataIntroToR\". Finally click Create Project . In the \"Files\" tab of your output pane (more about the RStudio layout in a moment), you should see an RStudio project file, IndigiDataIntroToR.Rproj . All RStudio projects end with the \" .Rproj \" file extension.","title":"Create an RStudio project"},{"location":"1_Background/#creating-your-first-r-script","text":"Now that we are ready to start exploring R, we will want to keep a record of the commands we are using. To do this we can create an R script: Click the File menu and select New File and then R Script . Before we go any further, save your script by clicking the save/disk icon that is in the bar above the first line in the script editor, or click the File menu and select save . In the \"Save File\" window that opens, name your file \"indigidataIntroToR\" . The new script indigidataIntroToR.R should appear under \"files\" in the output pane. By convention, R scripts end with the file extension .R .","title":"Creating your first R script"},{"location":"1_Background/#getting-to-work-with-r-navigating-directories","text":"Now that we have covered the more aesthetic aspects of RStudio, we can get to work using some commands. We will write, execute, and save the commands we learn in our indigidataIntroToR.R script that is loaded in the Source pane. First, lets see what directory we are in. To do so, type the following command into the script: R-project getwd() To execute this command, make sure your cursor is on the same line the command is written. Then click the Run button that is just above the first line of your script in the header of the Source pane. In the console, we expect to see the following output : [1] \"/home/Documents/IndigiDataIntroToR\" Notice, at the Console, you will also see the instruction you executed above the output in blue. Since we will be learning several commands, we may already want to keep some short notes in our script to explain the purpose of the command. Entering a # before any line in an R script turns that line into a comment, which R will not try to interpret as code. Edit your script to include a comment on the purpose of commands you are learning, e.g.: R-project `# this command shows the current working directory getwd()` Exercise : Work interactively in R What happens when you try to enter the getwd() command in the Console pane? Solution You will get the same output you did as when you ran getwd() from the source. You can run any command in the Console, however, executing it from the source script will make it easier for us to record what we have done, and ultimately run an entire script, instead of entering commands one-by-one. For the purposes of this exercise we want you to be in the directory \"/home/<USERID>/IndigiDataIntroToR\" . What if you weren't? You can set your home directory using the setwd() command. Alternatively, RStudio has a helpful button for setting your working directory ( note that this is a very simplified way to set your working directory, and this is actually a bit more complex in practice.)","title":"Getting to work with R: navigating directories"},{"location":"1_Background/#using-functions-in-r-without-needing-to-master-them","text":"A function in R (or any computing language) is a short program that takes some input and returns some output. Functions may seem like an advanced topic (and they are), but you have already used at least one function in R. getwd() is a function! The next sections will help you understand what is happening in any R script. Exercise: What do these functions do? Try the following functions by writing them in your script. See if you can guess what they do, and make sure to add comments to your script about your assumed purpose. - dir() - sessionInfo() - date() - Sys.time() Solution dir() # Lists files in the working directory sessionInfo() # Gives the version of R and additional info including on attached packages date() # Gives the current date Sys.time() # Gives the current time .libPaths() # Shows what libraries are available Notice : Commands are case sensitive! You have hopefully noticed a pattern - an R function has three key properties: Functions have a name (e.g. dir , getwd ); note that functions are case sensitive! Following the name, functions have a pair of () Inside the parentheses, a function may take 0 or more arguments. An argument may be a specific input for your function and/or may modify the function's behavior. For example the function round() will round a number with a decimal: R-project # This will round a number to the nearest integer round(3.14)","title":"Using functions in R, without needing to master them"},{"location":"1_Background/#getting-help-with-function-arguments","text":"What if you wanted to round to one significant digit? round() can do this, but you may first need to read the help to find out how. To see the help (In R sometimes also called a \"vignette\") enter a ? in front of the function name: R-project ?round() The \"Help\" tab will show you information (often, too much information). You will slowly learn how to read and make sense of help files. Checking the \"Usage\" or \"Examples\" headings is often a good place to look first. If you look under \"Arguments,\" we also see what arguments we can pass to this function to modify its behavior. You can also see a function's argument using the args() function: R-project args(round) round() takes two arguments, x , which is the number to be rounded, and a digits argument. The = sign indicates that a default (in this case 0) is already set. Since x is not set, round() requires we provide it, in contrast to digits where R will use the default value 0 unless you explicitly provide a different value. We can explicitly set the digits parameter when we call the function: R-project round(3.14159, digits = 2) Or, R accepts what we call \"positional arguments\", if you pass a function arguments separated by commas, R assumes that they are in the order you saw when we used args() . In the case below that means that x is 3.14159 and digits is 2. R-project round(3.14159, 2) Finally, what if you are using ? to get help for a function in a package not installed on your system, such as when you are running a script which has dependencies. R-project geom_point() will return an error: Error Error in .helpForCall(topicExpr, parent.frame()) : no methods for \u2018geom_point\u2019 and no documentation for it as a function Use two question marks (i.e. ??geom_point() ) and R will return results from a search of the documentation for packages you have installed on your computer in the \"Help\" tab. Finally, if you think there should be a function, for example a statistical test, but you aren't sure what it is called in R, or what functions may be available, use the help.search() function. Exercise: Searching for R functions Use help.search() to find R functions for the following statistical functions. Remember to put your search query in quotes inside the function's parentheses. Chi-Squared test Student t-test mixed linear model Success While your search results may return several tests, we list a few you might find: Chi-Squared test: stats::Chisquare Student t-test: stats::t.test mixed linear model: stats::lm.glm","title":"Getting help with function arguments"},{"location":"2_WorkingWithData/","text":"Analysing genetic variant data in R \u00b6 Info Keypoints Objectives R can hold data as Objects and Functions can be used to ask questions of that data The 1000 Genomes Project is a public resource for genetic data SNPS (Single Nucleotide Polymorphisms) are small changes to our DNA that can be medically relevant Load publicly (freely) available data from The 1000 Genomes Project into R Understand how SNP data varies between populations The data: Single Nucleotide Polymorphisms (SNPS) from the 1000 Genomes Project \u00b6 The data you will be working with today is publicly available high-throughput sequencing data from a resource called the 1000 genomes project. We have downloaded a (small) subset of the 1000 genomes data, called the file snpData.txt, and placed it in your home directory ( /home/Documents/IndigiDataIntroToR/ ). To read the 'snpData.txt' data file into R, we will use the read.table() function: R-project # Read in the txt file and save it as 'snpData' snpData <- read.table ( \"/home/Documents/IndigiDataIntroToR/snpData.txt\" , sep = '\\t' , header = T ) Here we used the read.table function to follow a file path, select a file (snpData.txt), and read it (with the help of some extra arguments like 'sep' and 'header' that tell R about the format of the file). We've also done something new: we have taken the output of the read.table function and stored it in something called an object. In other languages we might use the term 'variable'. Let's use some other functions to inspect the data and learn basic facts about the structure of our data object: R-project # The dim function will tell us how many rows (individuals) and columns the dataset contains: dim ( snpData ) ## [1] 2504 9 This tells us there are 2504 rows and 9 columns. We know that the rows are individuals, but what are the columns? The 'names' function can be used to the column names: R-project names ( snpData ) Output ## [1] \"SubjectID\" \"Population\" \"rs3826656\" \"rs13387042\" \"rs4779584\" \"rs2398162\" \"rs1344706\" \"rs7659604\" \"rs734553\" This function shows us the names of the nine columns: The first two tell us the SubjectID (an identifier for the individual from whom the data was collected) and Population (where the individual came from). The next seven names are \"rs\" followed by a string of numbers. These rs numbers are SNP names - each known SNP has a unique identifier. What are SNPs? \u00b6 SNPs (Single Nucleotide Polymorphisms) are places in the genome where some individuals in the population have variation at a single DNA base (e.g., some people may have an \"A\" base at a certain location in the genome, while others have a \"G\" at that exact same location). The majority of SNPs don't have a (known) impact on health or function, but some do. One of the things we often ask about a SNP is how common is it in the population. To look at the full dataset, you can use the View() function: R-project View ( snpData ) For each individual we can see the base pairs they have at the particular SNP location (locus) in the genome. Note that there are always two bases, one from each pair of chromosomes, so if a SNP is either an A or G an individual can be AA, AG, or GG. The second column is called \u201cPopulation\u201d. We can make a table of this information to see how many individuals are present in each population (the \u201c$\u201d sign tells R to use the \u201cPopulation\u201d column from the \u201csnpData\u201d\u201d object): R-project table ( snpData $ Population ) Output AFR AMR EAS EUR SAS 661 347 504 503 489 The super-population codes are: AFR, African; AMR, Ad-Mixed American; EAS, East Asian; EUR, European; SAS, South Asian. Additional information about the composition of these populations can be found at: http://www.internationalgenome.org/faq/which-populations-are-part-your-study Looking at SNP frequencies \u00b6 The other seven columns in the data set relate to specific single nucleotide polymorphisms (SNPs) in the genome - we have the genotype data for each SNP for every individual in the data set. We can use the \u201ctable\u201d command again to summarize the genotype information for each SNP: R-project ## Make a genotype frequency table for the first SNP table ( snpData $ rs3826656 ) Output AA AG GG 1112 952 440 We can also calculate the proportions associated with each genotype: ## Calculate proportions prop.table ( table ( snpData $ rs3826656 )) Output AA AG GG 0.4440895 0.3801917 0.1757188 and examine differences in genotype frequencies across populations: ## Create contingeny table - genotypes across populations table ( snpData $ Population , snpData $ rs3826656 ) Output AA AG GG AFR 445 199 17 AMR 225 109 13 EAS 47 224 233 EUR 312 161 30 SAS 83 259 147 ## And calculate proportions (rounded) round ( prop.table ( table ( snpData $ Population , snpData $ rs3826656 ), 1 ), 2 ) Output AA AG GG AFR 0.67 0.30 0.03 AMR 0.65 0.31 0.04 EAS 0.09 0.44 0.46 EUR 0.62 0.32 0.06 SAS 0.17 0.53 0.30 These results can be plotted as a bar plot: snpFreqs = t ( prop.table ( table ( snpData $ Population , snpData $ rs3826656 ), 1 )) barplot ( snpFreqs , beside = TRUE , legend.text = TRUE , ylim = c ( 0 , 1 )) These analyses can be repeated for different SNPs by changing the SNP ID (e.g., rs3826656) in the above commands. Why look at these SNPs? \u00b6 The seven SNPs contained in this data set were not just randomly chosen - they are SNPs that have been found to be associated with altered disease risk. That is, an individual\u2019s genotype at a particular position in the genome affects their risk of developing a particular disease. This is not absolute though, it really just raises or lowers the probability of disease - it doesn\u2019t guarantee complete protection or susceptibility. SNP Link Alleles Nearby Gene Disease rs3826656 http://www.snpedia.com/index.php/Rs3826656 A/G CD33 Alzheimer\u2019s Disease rs13387042 http://www.snpedia.com/index.php/Rs13387042 A/G DIRC3 Breast Cancer rs4779584 http://www.snpedia.com/index.php/Rs4779584 T/C GREM1 Colorectal Cancer rs2398162 http://www.snpedia.com/index.php/Rs2398162 A/G NR2F2 Hypertension rs1344706 http://www.snpedia.com/index.php/Rs1344706 A/C ZNF408A Schizophrenia and Bipolar Disorder rs7659604 http://www.snpedia.com/index.php/Rs7659604 T/C TMEM155 Type 2 Diabetes rs734553 http://www.snpedia.com/index.php/Rs734553 T/G SLC2A9 Gout For each SNP, increased risk of disease is associated with the minor allele. Variation in genotype frequencies across populations can help to explain some of the population-specific differences in rates of different diseases. Clicking on SNP IDs in the table above will link through to aditional information about each variant.","title":"Analysing genetic variant data in R"},{"location":"2_WorkingWithData/#analysing-genetic-variant-data-in-r","text":"Info Keypoints Objectives R can hold data as Objects and Functions can be used to ask questions of that data The 1000 Genomes Project is a public resource for genetic data SNPS (Single Nucleotide Polymorphisms) are small changes to our DNA that can be medically relevant Load publicly (freely) available data from The 1000 Genomes Project into R Understand how SNP data varies between populations","title":"Analysing genetic variant data in R"},{"location":"2_WorkingWithData/#the-data-single-nucleotide-polymorphisms-snps-from-the-1000-genomes-project","text":"The data you will be working with today is publicly available high-throughput sequencing data from a resource called the 1000 genomes project. We have downloaded a (small) subset of the 1000 genomes data, called the file snpData.txt, and placed it in your home directory ( /home/Documents/IndigiDataIntroToR/ ). To read the 'snpData.txt' data file into R, we will use the read.table() function: R-project # Read in the txt file and save it as 'snpData' snpData <- read.table ( \"/home/Documents/IndigiDataIntroToR/snpData.txt\" , sep = '\\t' , header = T ) Here we used the read.table function to follow a file path, select a file (snpData.txt), and read it (with the help of some extra arguments like 'sep' and 'header' that tell R about the format of the file). We've also done something new: we have taken the output of the read.table function and stored it in something called an object. In other languages we might use the term 'variable'. Let's use some other functions to inspect the data and learn basic facts about the structure of our data object: R-project # The dim function will tell us how many rows (individuals) and columns the dataset contains: dim ( snpData ) ## [1] 2504 9 This tells us there are 2504 rows and 9 columns. We know that the rows are individuals, but what are the columns? The 'names' function can be used to the column names: R-project names ( snpData ) Output ## [1] \"SubjectID\" \"Population\" \"rs3826656\" \"rs13387042\" \"rs4779584\" \"rs2398162\" \"rs1344706\" \"rs7659604\" \"rs734553\" This function shows us the names of the nine columns: The first two tell us the SubjectID (an identifier for the individual from whom the data was collected) and Population (where the individual came from). The next seven names are \"rs\" followed by a string of numbers. These rs numbers are SNP names - each known SNP has a unique identifier.","title":"The data: Single Nucleotide Polymorphisms (SNPS) from the 1000 Genomes Project"},{"location":"2_WorkingWithData/#what-are-snps","text":"SNPs (Single Nucleotide Polymorphisms) are places in the genome where some individuals in the population have variation at a single DNA base (e.g., some people may have an \"A\" base at a certain location in the genome, while others have a \"G\" at that exact same location). The majority of SNPs don't have a (known) impact on health or function, but some do. One of the things we often ask about a SNP is how common is it in the population. To look at the full dataset, you can use the View() function: R-project View ( snpData ) For each individual we can see the base pairs they have at the particular SNP location (locus) in the genome. Note that there are always two bases, one from each pair of chromosomes, so if a SNP is either an A or G an individual can be AA, AG, or GG. The second column is called \u201cPopulation\u201d. We can make a table of this information to see how many individuals are present in each population (the \u201c$\u201d sign tells R to use the \u201cPopulation\u201d column from the \u201csnpData\u201d\u201d object): R-project table ( snpData $ Population ) Output AFR AMR EAS EUR SAS 661 347 504 503 489 The super-population codes are: AFR, African; AMR, Ad-Mixed American; EAS, East Asian; EUR, European; SAS, South Asian. Additional information about the composition of these populations can be found at: http://www.internationalgenome.org/faq/which-populations-are-part-your-study","title":"What are SNPs?"},{"location":"2_WorkingWithData/#looking-at-snp-frequencies","text":"The other seven columns in the data set relate to specific single nucleotide polymorphisms (SNPs) in the genome - we have the genotype data for each SNP for every individual in the data set. We can use the \u201ctable\u201d command again to summarize the genotype information for each SNP: R-project ## Make a genotype frequency table for the first SNP table ( snpData $ rs3826656 ) Output AA AG GG 1112 952 440 We can also calculate the proportions associated with each genotype: ## Calculate proportions prop.table ( table ( snpData $ rs3826656 )) Output AA AG GG 0.4440895 0.3801917 0.1757188 and examine differences in genotype frequencies across populations: ## Create contingeny table - genotypes across populations table ( snpData $ Population , snpData $ rs3826656 ) Output AA AG GG AFR 445 199 17 AMR 225 109 13 EAS 47 224 233 EUR 312 161 30 SAS 83 259 147 ## And calculate proportions (rounded) round ( prop.table ( table ( snpData $ Population , snpData $ rs3826656 ), 1 ), 2 ) Output AA AG GG AFR 0.67 0.30 0.03 AMR 0.65 0.31 0.04 EAS 0.09 0.44 0.46 EUR 0.62 0.32 0.06 SAS 0.17 0.53 0.30 These results can be plotted as a bar plot: snpFreqs = t ( prop.table ( table ( snpData $ Population , snpData $ rs3826656 ), 1 )) barplot ( snpFreqs , beside = TRUE , legend.text = TRUE , ylim = c ( 0 , 1 )) These analyses can be repeated for different SNPs by changing the SNP ID (e.g., rs3826656) in the above commands.","title":"Looking at SNP frequencies"},{"location":"2_WorkingWithData/#why-look-at-these-snps","text":"The seven SNPs contained in this data set were not just randomly chosen - they are SNPs that have been found to be associated with altered disease risk. That is, an individual\u2019s genotype at a particular position in the genome affects their risk of developing a particular disease. This is not absolute though, it really just raises or lowers the probability of disease - it doesn\u2019t guarantee complete protection or susceptibility. SNP Link Alleles Nearby Gene Disease rs3826656 http://www.snpedia.com/index.php/Rs3826656 A/G CD33 Alzheimer\u2019s Disease rs13387042 http://www.snpedia.com/index.php/Rs13387042 A/G DIRC3 Breast Cancer rs4779584 http://www.snpedia.com/index.php/Rs4779584 T/C GREM1 Colorectal Cancer rs2398162 http://www.snpedia.com/index.php/Rs2398162 A/G NR2F2 Hypertension rs1344706 http://www.snpedia.com/index.php/Rs1344706 A/C ZNF408A Schizophrenia and Bipolar Disorder rs7659604 http://www.snpedia.com/index.php/Rs7659604 T/C TMEM155 Type 2 Diabetes rs734553 http://www.snpedia.com/index.php/Rs734553 T/G SLC2A9 Gout For each SNP, increased risk of disease is associated with the minor allele. Variation in genotype frequencies across populations can help to explain some of the population-specific differences in rates of different diseases. Clicking on SNP IDs in the table above will link through to aditional information about each variant.","title":"Why look at these SNPs?"},{"location":"3_AnalysingTwoDataTypes/","text":"R for statistical tools and tests \u00b6 Info Keypoints Objectives R is popular for statistical tests PCA can make your data easier to comprehend Genetic variation can be population-specific Investigate diversity in population-specific genetic variation Understand PCA and how to run it in R Population diversity \u00b6 We will now load a second dataset which contains a new set of SNPs. Rather than being medically relevant, these SNPs were chosen because they are informative about ancestry. That is, variation in their genotype frequencies tends to be associated with differences between population groups. R-project ## Load ancestry data snpAns = read.table ( 'GENE360snpAncestry.txt' , header = T , sep = '\\t' ) ## Check dimensionality of data dim ( snpAns ) Output [1] 2504 2305 Now we now have a much larger dataset: 2504 individuals and 2302 SNP genotypes for each individual. Note : I've said there are 2302 SNP genotypes, but the dim function above returned 2305 columns. Think back to some of the functions you have used earlier and use one (or more) to check what the other three columns are. Solution A) !!! r-project ```r View(snpAns) ``` B) !!! r-project ```r names(snpAns) ``` This new dataset includes not just the super populations we worked with previously, but also sub-populations. We can create a table that breaks down each super population into subpopulations: R-project table ( snpAns $ SubPopulation , snpAns $ Population ) Output ## ## AFR AMR EAS EUR SAS ## AFR_ACB 96 0 0 0 0 ## AFR_ASW 61 0 0 0 0 ## AFR_ESN 99 0 0 0 0 ## AFR_GWD 113 0 0 0 0 ## AFR_LWK 99 0 0 0 0 ## AFR_MSL 85 0 0 0 0 ## AFR_YRI 108 0 0 0 0 ## AMR_CLM 0 94 0 0 0 ## AMR_MXL 0 64 0 0 0 ## AMR_PEL 0 85 0 0 0 ## AMR_PUR 0 104 0 0 0 ## EAS_CDX 0 0 93 0 0 ## EAS_CHB 0 0 103 0 0 ## EAS_CHS 0 0 105 0 0 ## EAS_JPT 0 0 104 0 0 ## EAS_KHV 0 0 99 0 0 ## EUR_CEU 0 0 0 99 0 ## EUR_FIN 0 0 0 99 0 ## EUR_GBR 0 0 0 91 0 ## EUR_IBS 0 0 0 107 0 ## EUR_TSI 0 0 0 107 0 ## SAS_BEB 0 0 0 0 86 ## SAS_GIH 0 0 0 0 103 ## SAS_ITU 0 0 0 0 102 ## SAS_PJL 0 0 0 0 96 ## SAS_STU 0 0 0 0 102 To examine population diversity we need to do two things: Create a data object of only the SNP genotype data (i.e., remove the first three columns). Convert the genotypes to allele counts (e.g., if we wanted to count the number of A's: TT, AT, AA becomes 0, 1, 2, respectively). Step 1: R-project ## Create a new object called snpAnsDat which contains only the SNP data. ## To do this we will take all the data from snpAns except rows 1, 2 and 3: snpAnsData = snpAns [, - c ( 1 , 2 , 3 )] Step 2: R-project ## Load a custom function to convert genotypes (AA, AT, TT) into allele counts (2, 1, 0 if we are counting A's). alleleCounts <- function ( x ){ gt <- names ( table ( x )) alleles <- unique ( unlist ( strsplit ( gt , '' ))) oo <- order ( sapply ( alleles , function ( z ) sum ( grep ( z , x ))), decreasing = T ) alleles <- alleles [ oo ] geno <- c ( paste ( alleles [ 1 ], alleles [ 1 ], collapse = '' , sep = '' ), paste ( sort ( alleles ), collapse = '' , sep = '' ), paste ( alleles [ 2 ], alleles [ 2 ], collapse = '' , sep = '' )) return ( sapply ( x , match , geno ) - 1 ) } source ( 'alleleCounts.R' ) ## Apply the function to the genotype data, one column (SNP) at a time. snpAnsCount = apply ( snpAnsData , 2 , alleleCounts ) We now have a new object that contains just the SNP data represented by allele counts. Let's look at this new data set using View(): R-project View ( snpAnsCount ) Principal components analysis (PCA) \u00b6 In terms of examining population diversity, we have 2302 dimensions of data available - one dimension for each SNP. Rather than trying to comprehend this huge amount of data in 2302-dimensional space, genetics researchers often use a statistical tool called Principal Components Analysis (PCA) to reduce the dimensionality of the data. The idea is to find the most important variation in the data, and examine the samples in terms of that variation, ignoring the rest. In practice, this works fairly well, because genetic differences between populations provide a strong (and relatively consistent) source of variation across genomic loci (i.e., SNPs). Rather than looking at 2302 dimensions of data, we end up looking at variation across just 2 or 3 dimensions - each dimension is defined by a combination of SNPs which vary in a similar way across the individuals in the study. R-project ## Load custom function to perform principal components analysis pcaGenotypes <- function ( x ){ sm <- colMeans ( x / 2 ) gg <- t ( t ( x / 2 ) - rowMeans ( t ( x / 2 ))) / sqrt ( sm * ( 1 - sm )) hh <- 1 / ncol ( x ) * gg %*% t ( gg ) return ( eigen ( hh ) $ vectors [, 1 : 3 ]) } source ( \"pcaGenotypes.R\" ) ## Apply this function to the allele count data ## This will take a couple of minutes to run pca = pcaGenotypes ( snpAnsCount ) To visualise the populations across the principal components, we need to define colours for each populations. It doesn't matter what colours you choose, but lets go with: AFR (brown), AMR (red), EAS (purple), EUR (blue), SAS (green). R-project ## Create an object relating to the population data ansPop = snpAns $ Population ## Generate colours to associate with each population pCols = c ( \"brown\" , \"red\" , \"purple\" , \"blue\" , \"green\" ) popCol = pCols [ as.numeric ( as.factor ( ansPop ))] names ( popCol ) = ansPop ## Check that they correspond to populations table ( popCol , ansPop ) Output ## ansPop ## popCol AFR AMR EAS EUR SAS ## blue 0 0 0 503 0 ## brown 661 0 0 0 0 ## green 0 0 0 0 489 ## purple 0 0 504 0 0 ## red 0 347 0 0 0 Now we can plot the principal components and colour the points based on the population each sample belongs to. R-project ## Load a custom plotting function to generate the plots: plotPCA <- function ( x , y ){ par ( mfrow = c ( 2 , 2 )) plot ( 0 , 0 , col = 'white' , xlim = c ( 0 , 1 ), ylim = c ( 0 , 1 ), axes = FALSE , xlab = '' , ylab = '' ) # legend(0.1,0.9,fill=rainbow(length(table(y))),names(table(names(y)))) colTab = table ( popCol , names ( popCol )) colTab = colTab [ apply ( colTab , 2 , which.max ),] pCol = rownames ( colTab ) names ( pCol ) = colnames ( colTab ) legend ( 0.1 , 0.9 , fill = pCol , names ( pCol )) plot ( x [, 1 ], x [, 2 ], pch = 20 , col = popCol , xlab = \"PC 1\" , ylab = \"PC 2\" ) plot ( x [, 1 ], x [, 3 ], pch = 20 , col = popCol , xlab = \"PC 1\" , ylab = \"PC 3\" ) plot ( x [, 2 ], x [, 3 ], pch = 20 , col = popCol , xlab = \"PC 2\" , ylab = \"PC 3\" ) } source ( 'plotPCA.R' ) ## Plot the PCA data that we have generated, along with the population information plotPCA ( pca , popCol ) From the plots we can see that samples from the same population tend to cluster together, and that the first three principal components do a reasonable job of capturing the genetic diversity between the populations. With the scatterplot3d package, you can plot the first three principal components at once (i.e., combining the information from the three scatterplots above). This shows that the European (EUR), East Asian (EAS) and South Asian (SAS) super-populations are relatively homogeneous, while the Ad-Mixed American (AMR) and African (AFR) super-populations exhibit greater variation, suggesting admixture within these groups. R-project library ( scatterplot3d ) scatterplot3d ( pca [, 1 ], pca [, 2 ], pca [, 3 ], color = popCol , pch = 16 , cex.symbols = 0.5 , xlab = \"PC1\" , ylab = \"PC2\" , zlab = \"PC3\" ) Phylogenetic trees \u00b6 Another way to visualise genetic similarity is via \u201cphylogenetic trees\u201d, also known more generally as \u201cdendrograms\u201d. These tree diagrams group items together based on similarity scores. In this setting our \u201citems\u201d are the populations, and the scores are calculated based on the genetic similarities between each pair of populations. To calculate similarities, we need to create a set of \u201caverage\u201d genotypes for each population. One way to do this is to calculate the frequency of the major homozygote for each SNP in each population. R-project ## Load custom function for calculating major homozygote frequency: calcMajorFreq <- function ( x , y ){ ## x is count-based genotypes ## y is population data pops <- names ( table ( y )) gtFreq <- matrix ( 0 , length ( pops ), ncol ( x )) for ( i in seq ( pops )) gtFreq [ i ,] <- apply ( x [ as.vector ( y ) == pops [ i ],], 2 , function ( z ) 1 - prop.table ( table ( z ))[ 1 ]) gtFreq [ is.na ( gtFreq )] <- 0 rownames ( gtFreq ) <- pops colnames ( gtFreq ) <- colnames ( x ) return ( gtFreq ) } source ( 'calcMajorFreq.R' ) ## Apply this function to the SNP count data ## Takes a few seconds popFreqs = calcMajorFreq ( snpAnsCount , ansPop ) R-project ## Make a cluster tree based on these frequencies plot ( hclust ( dist ( popFreqs )), hang = -1 ) The way in which the \u201cleaves\u201d of the tree cluster, reflects the similarity between the items analysed. In this case the populations are grouped based on their genetic similarity, as measured by these particular loci. Here it appears that the AMR (Ad-Mixed American), and SAS (South Asian) super-populations are most genetically similar, then EUR (European), followed by EAS (East Asian). The AFR (African) super-population is the most genetically dissimilar relative to the others. It is likely that these groupings reflect (to some degree) migration patterns and shared ancestry experienced by these populations. Key takeaways \u00b6 R has hundreds of functions that can do a wide range of tasks, from simple (view data, calculate mean, show you the range (min/max) values) to highly complex. R is an excellent programming language for statistical analyses of large data sets. R is really useful for making quick plots and tables to visualise your data. Large, publicly available datasets are a tremendous resource.","title":"R for statistical tools and tests"},{"location":"3_AnalysingTwoDataTypes/#r-for-statistical-tools-and-tests","text":"Info Keypoints Objectives R is popular for statistical tests PCA can make your data easier to comprehend Genetic variation can be population-specific Investigate diversity in population-specific genetic variation Understand PCA and how to run it in R","title":"R for statistical tools and tests"},{"location":"3_AnalysingTwoDataTypes/#population-diversity","text":"We will now load a second dataset which contains a new set of SNPs. Rather than being medically relevant, these SNPs were chosen because they are informative about ancestry. That is, variation in their genotype frequencies tends to be associated with differences between population groups. R-project ## Load ancestry data snpAns = read.table ( 'GENE360snpAncestry.txt' , header = T , sep = '\\t' ) ## Check dimensionality of data dim ( snpAns ) Output [1] 2504 2305 Now we now have a much larger dataset: 2504 individuals and 2302 SNP genotypes for each individual. Note : I've said there are 2302 SNP genotypes, but the dim function above returned 2305 columns. Think back to some of the functions you have used earlier and use one (or more) to check what the other three columns are. Solution A) !!! r-project ```r View(snpAns) ``` B) !!! r-project ```r names(snpAns) ``` This new dataset includes not just the super populations we worked with previously, but also sub-populations. We can create a table that breaks down each super population into subpopulations: R-project table ( snpAns $ SubPopulation , snpAns $ Population ) Output ## ## AFR AMR EAS EUR SAS ## AFR_ACB 96 0 0 0 0 ## AFR_ASW 61 0 0 0 0 ## AFR_ESN 99 0 0 0 0 ## AFR_GWD 113 0 0 0 0 ## AFR_LWK 99 0 0 0 0 ## AFR_MSL 85 0 0 0 0 ## AFR_YRI 108 0 0 0 0 ## AMR_CLM 0 94 0 0 0 ## AMR_MXL 0 64 0 0 0 ## AMR_PEL 0 85 0 0 0 ## AMR_PUR 0 104 0 0 0 ## EAS_CDX 0 0 93 0 0 ## EAS_CHB 0 0 103 0 0 ## EAS_CHS 0 0 105 0 0 ## EAS_JPT 0 0 104 0 0 ## EAS_KHV 0 0 99 0 0 ## EUR_CEU 0 0 0 99 0 ## EUR_FIN 0 0 0 99 0 ## EUR_GBR 0 0 0 91 0 ## EUR_IBS 0 0 0 107 0 ## EUR_TSI 0 0 0 107 0 ## SAS_BEB 0 0 0 0 86 ## SAS_GIH 0 0 0 0 103 ## SAS_ITU 0 0 0 0 102 ## SAS_PJL 0 0 0 0 96 ## SAS_STU 0 0 0 0 102 To examine population diversity we need to do two things: Create a data object of only the SNP genotype data (i.e., remove the first three columns). Convert the genotypes to allele counts (e.g., if we wanted to count the number of A's: TT, AT, AA becomes 0, 1, 2, respectively). Step 1: R-project ## Create a new object called snpAnsDat which contains only the SNP data. ## To do this we will take all the data from snpAns except rows 1, 2 and 3: snpAnsData = snpAns [, - c ( 1 , 2 , 3 )] Step 2: R-project ## Load a custom function to convert genotypes (AA, AT, TT) into allele counts (2, 1, 0 if we are counting A's). alleleCounts <- function ( x ){ gt <- names ( table ( x )) alleles <- unique ( unlist ( strsplit ( gt , '' ))) oo <- order ( sapply ( alleles , function ( z ) sum ( grep ( z , x ))), decreasing = T ) alleles <- alleles [ oo ] geno <- c ( paste ( alleles [ 1 ], alleles [ 1 ], collapse = '' , sep = '' ), paste ( sort ( alleles ), collapse = '' , sep = '' ), paste ( alleles [ 2 ], alleles [ 2 ], collapse = '' , sep = '' )) return ( sapply ( x , match , geno ) - 1 ) } source ( 'alleleCounts.R' ) ## Apply the function to the genotype data, one column (SNP) at a time. snpAnsCount = apply ( snpAnsData , 2 , alleleCounts ) We now have a new object that contains just the SNP data represented by allele counts. Let's look at this new data set using View(): R-project View ( snpAnsCount )","title":"Population diversity"},{"location":"3_AnalysingTwoDataTypes/#principal-components-analysis-pca","text":"In terms of examining population diversity, we have 2302 dimensions of data available - one dimension for each SNP. Rather than trying to comprehend this huge amount of data in 2302-dimensional space, genetics researchers often use a statistical tool called Principal Components Analysis (PCA) to reduce the dimensionality of the data. The idea is to find the most important variation in the data, and examine the samples in terms of that variation, ignoring the rest. In practice, this works fairly well, because genetic differences between populations provide a strong (and relatively consistent) source of variation across genomic loci (i.e., SNPs). Rather than looking at 2302 dimensions of data, we end up looking at variation across just 2 or 3 dimensions - each dimension is defined by a combination of SNPs which vary in a similar way across the individuals in the study. R-project ## Load custom function to perform principal components analysis pcaGenotypes <- function ( x ){ sm <- colMeans ( x / 2 ) gg <- t ( t ( x / 2 ) - rowMeans ( t ( x / 2 ))) / sqrt ( sm * ( 1 - sm )) hh <- 1 / ncol ( x ) * gg %*% t ( gg ) return ( eigen ( hh ) $ vectors [, 1 : 3 ]) } source ( \"pcaGenotypes.R\" ) ## Apply this function to the allele count data ## This will take a couple of minutes to run pca = pcaGenotypes ( snpAnsCount ) To visualise the populations across the principal components, we need to define colours for each populations. It doesn't matter what colours you choose, but lets go with: AFR (brown), AMR (red), EAS (purple), EUR (blue), SAS (green). R-project ## Create an object relating to the population data ansPop = snpAns $ Population ## Generate colours to associate with each population pCols = c ( \"brown\" , \"red\" , \"purple\" , \"blue\" , \"green\" ) popCol = pCols [ as.numeric ( as.factor ( ansPop ))] names ( popCol ) = ansPop ## Check that they correspond to populations table ( popCol , ansPop ) Output ## ansPop ## popCol AFR AMR EAS EUR SAS ## blue 0 0 0 503 0 ## brown 661 0 0 0 0 ## green 0 0 0 0 489 ## purple 0 0 504 0 0 ## red 0 347 0 0 0 Now we can plot the principal components and colour the points based on the population each sample belongs to. R-project ## Load a custom plotting function to generate the plots: plotPCA <- function ( x , y ){ par ( mfrow = c ( 2 , 2 )) plot ( 0 , 0 , col = 'white' , xlim = c ( 0 , 1 ), ylim = c ( 0 , 1 ), axes = FALSE , xlab = '' , ylab = '' ) # legend(0.1,0.9,fill=rainbow(length(table(y))),names(table(names(y)))) colTab = table ( popCol , names ( popCol )) colTab = colTab [ apply ( colTab , 2 , which.max ),] pCol = rownames ( colTab ) names ( pCol ) = colnames ( colTab ) legend ( 0.1 , 0.9 , fill = pCol , names ( pCol )) plot ( x [, 1 ], x [, 2 ], pch = 20 , col = popCol , xlab = \"PC 1\" , ylab = \"PC 2\" ) plot ( x [, 1 ], x [, 3 ], pch = 20 , col = popCol , xlab = \"PC 1\" , ylab = \"PC 3\" ) plot ( x [, 2 ], x [, 3 ], pch = 20 , col = popCol , xlab = \"PC 2\" , ylab = \"PC 3\" ) } source ( 'plotPCA.R' ) ## Plot the PCA data that we have generated, along with the population information plotPCA ( pca , popCol ) From the plots we can see that samples from the same population tend to cluster together, and that the first three principal components do a reasonable job of capturing the genetic diversity between the populations. With the scatterplot3d package, you can plot the first three principal components at once (i.e., combining the information from the three scatterplots above). This shows that the European (EUR), East Asian (EAS) and South Asian (SAS) super-populations are relatively homogeneous, while the Ad-Mixed American (AMR) and African (AFR) super-populations exhibit greater variation, suggesting admixture within these groups. R-project library ( scatterplot3d ) scatterplot3d ( pca [, 1 ], pca [, 2 ], pca [, 3 ], color = popCol , pch = 16 , cex.symbols = 0.5 , xlab = \"PC1\" , ylab = \"PC2\" , zlab = \"PC3\" )","title":"Principal components analysis (PCA)"},{"location":"3_AnalysingTwoDataTypes/#phylogenetic-trees","text":"Another way to visualise genetic similarity is via \u201cphylogenetic trees\u201d, also known more generally as \u201cdendrograms\u201d. These tree diagrams group items together based on similarity scores. In this setting our \u201citems\u201d are the populations, and the scores are calculated based on the genetic similarities between each pair of populations. To calculate similarities, we need to create a set of \u201caverage\u201d genotypes for each population. One way to do this is to calculate the frequency of the major homozygote for each SNP in each population. R-project ## Load custom function for calculating major homozygote frequency: calcMajorFreq <- function ( x , y ){ ## x is count-based genotypes ## y is population data pops <- names ( table ( y )) gtFreq <- matrix ( 0 , length ( pops ), ncol ( x )) for ( i in seq ( pops )) gtFreq [ i ,] <- apply ( x [ as.vector ( y ) == pops [ i ],], 2 , function ( z ) 1 - prop.table ( table ( z ))[ 1 ]) gtFreq [ is.na ( gtFreq )] <- 0 rownames ( gtFreq ) <- pops colnames ( gtFreq ) <- colnames ( x ) return ( gtFreq ) } source ( 'calcMajorFreq.R' ) ## Apply this function to the SNP count data ## Takes a few seconds popFreqs = calcMajorFreq ( snpAnsCount , ansPop ) R-project ## Make a cluster tree based on these frequencies plot ( hclust ( dist ( popFreqs )), hang = -1 ) The way in which the \u201cleaves\u201d of the tree cluster, reflects the similarity between the items analysed. In this case the populations are grouped based on their genetic similarity, as measured by these particular loci. Here it appears that the AMR (Ad-Mixed American), and SAS (South Asian) super-populations are most genetically similar, then EUR (European), followed by EAS (East Asian). The AFR (African) super-population is the most genetically dissimilar relative to the others. It is likely that these groupings reflect (to some degree) migration patterns and shared ancestry experienced by these populations.","title":"Phylogenetic trees"},{"location":"3_AnalysingTwoDataTypes/#key-takeaways","text":"R has hundreds of functions that can do a wide range of tasks, from simple (view data, calculate mean, show you the range (min/max) values) to highly complex. R is an excellent programming language for statistical analyses of large data sets. R is really useful for making quick plots and tables to visualise your data. Large, publicly available datasets are a tremendous resource.","title":"Key takeaways"}]}